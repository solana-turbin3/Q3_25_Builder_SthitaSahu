"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExtraAccountRequiredInputs = exports.extraAccountFromBase = exports.extraAccountToBase = exports.extraAccountToAccountMeta = exports.findPreconfiguredPda = exports.PRECONFIGURED_SEED = void 0;
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const seed_1 = require("./seed");
const utils_1 = require("../utils");
exports.PRECONFIGURED_SEED = 'mpl-core';
const findPreconfiguredPda = (context, program, key) => context.eddsa.findPda(program, [
    (0, serializers_1.string)({ size: 'variable' }).serialize(exports.PRECONFIGURED_SEED),
    (0, serializers_1.publicKey)().serialize(key),
]);
exports.findPreconfiguredPda = findPreconfiguredPda;
function extraAccountToAccountMeta(context, e, inputs) {
    const acccountMeta = {
        isSigner: e.isSigner || false,
        isWritable: e.isWritable || false,
    };
    const requiredInputs = getExtraAccountRequiredInputs(e);
    const missing = [];
    requiredInputs.forEach((input) => {
        if (!inputs[input]) {
            missing.push(input);
        }
    });
    if (missing.length) {
        throw new Error(`Missing required inputs to derive account address: ${missing.join(', ')}`);
    }
    switch (e.type) {
        case 'PreconfiguredProgram':
            return {
                ...acccountMeta,
                pubkey: context.eddsa.findPda(inputs.program, [
                    (0, serializers_1.string)({ size: 'variable' }).serialize(exports.PRECONFIGURED_SEED),
                ])[0],
            };
        case 'PreconfiguredCollection':
            return {
                ...acccountMeta,
                pubkey: (0, exports.findPreconfiguredPda)(context, inputs.program, inputs.collection)[0],
            };
        case 'PreconfiguredOwner':
            return {
                ...acccountMeta,
                pubkey: (0, exports.findPreconfiguredPda)(context, inputs.program, inputs.owner)[0],
            };
        case 'PreconfiguredRecipient':
            return {
                ...acccountMeta,
                pubkey: (0, exports.findPreconfiguredPda)(context, inputs.program, inputs.recipient)[0],
            };
        case 'PreconfiguredAsset':
            return {
                ...acccountMeta,
                pubkey: (0, exports.findPreconfiguredPda)(context, inputs.program, inputs.asset)[0],
            };
        case 'CustomPda':
            return {
                pubkey: context.eddsa.findPda(e.customProgramId ? e.customProgramId : inputs.program, e.seeds.map((seed) => {
                    switch (seed.type) {
                        case 'Collection':
                            return (0, serializers_1.publicKey)().serialize(inputs.collection);
                        case 'Owner':
                            return (0, serializers_1.publicKey)().serialize(inputs.owner);
                        case 'Recipient':
                            return (0, serializers_1.publicKey)().serialize(inputs.recipient);
                        case 'Asset':
                            return (0, serializers_1.publicKey)().serialize(inputs.asset);
                        case 'Address':
                            return (0, serializers_1.publicKey)().serialize(seed.pubkey);
                        case 'Bytes':
                            return seed.bytes;
                        default:
                            throw new Error('Unknown seed type');
                    }
                }))[0],
                ...acccountMeta,
            };
        case 'Address':
            return {
                ...acccountMeta,
                pubkey: e.address,
            };
        default:
            throw new Error('Unknown extra account type');
    }
}
exports.extraAccountToAccountMeta = extraAccountToAccountMeta;
function extraAccountToBase(s) {
    const acccountMeta = {
        isSigner: s.isSigner || false,
        isWritable: s.isWritable || false,
    };
    if (s.type === 'CustomPda') {
        return {
            __kind: 'CustomPda',
            ...acccountMeta,
            seeds: s.seeds.map(seed_1.seedToBase),
            customProgramId: (0, utils_1.someOrNone)(s.customProgramId),
        };
    }
    if (s.type === 'Address') {
        return {
            __kind: 'Address',
            ...acccountMeta,
            address: s.address,
        };
    }
    return {
        __kind: s.type,
        ...acccountMeta,
    };
}
exports.extraAccountToBase = extraAccountToBase;
function extraAccountFromBase(s) {
    if (s.__kind === 'CustomPda') {
        return {
            type: 'CustomPda',
            isSigner: s.isSigner,
            isWritable: s.isWritable,
            seeds: s.seeds.map(seed_1.seedFromBase),
            customProgramId: (0, utils_1.unwrapOption)(s.customProgramId),
        };
    }
    if (s.__kind === 'Address') {
        return {
            type: 'Address',
            isSigner: s.isSigner,
            isWritable: s.isWritable,
            address: s.address,
        };
    }
    return {
        type: s.__kind,
        isSigner: s.isSigner,
        isWritable: s.isWritable,
    };
}
exports.extraAccountFromBase = extraAccountFromBase;
const EXTRA_ACCOUNT_INPUT_MAP = {
    PreconfiguredOwner: 'owner',
    PreconfiguredRecipient: 'recipient',
    PreconfiguredAsset: 'asset',
    PreconfiguredCollection: 'collection',
    PreconfiguredProgram: 'program',
};
function getExtraAccountRequiredInputs(s) {
    const preconfigured = EXTRA_ACCOUNT_INPUT_MAP[s.type];
    if (preconfigured) {
        return [preconfigured];
    }
    if (s.type === 'CustomPda') {
        return s.seeds
            .map((seed) => {
            switch (seed.type) {
                case 'Collection':
                    return 'collection';
                case 'Owner':
                    return 'owner';
                case 'Recipient':
                    return 'recipient';
                case 'Asset':
                    return 'asset';
                default:
                    return null;
            }
        })
            .filter((input) => input);
    }
    return [];
}
exports.getExtraAccountRequiredInputs = getExtraAccountRequiredInputs;
//# sourceMappingURL=extraAccount.js.map
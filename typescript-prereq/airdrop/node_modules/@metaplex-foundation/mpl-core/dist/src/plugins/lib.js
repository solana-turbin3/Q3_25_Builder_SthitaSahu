"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseExternalPluginAdapterData = exports.pluginKeyToPluginType = exports.registryRecordsToPluginsList = exports.mapPlugin = exports.mapPluginFields = exports.pluginAuthorityPairV2 = exports.createPluginV2 = exports.pluginAuthorityPair = exports.createPlugin = exports.formPluginHeaderV1 = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const msgpack_1 = require("@msgpack/msgpack");
const generated_1 = require("../generated");
const utils_1 = require("../utils");
const masterEdition_1 = require("./masterEdition");
const pluginAuthority_1 = require("./pluginAuthority");
const royalties_1 = require("./royalties");
function formPluginHeaderV1(pluginRegistryOffset) {
    return {
        key: generated_1.Key.PluginHeaderV1,
        pluginRegistryOffset,
    };
}
exports.formPluginHeaderV1 = formPluginHeaderV1;
/**
 * @deprecated Use the new 1.0 sdk instruction helpers like `create` instead of `createV1` which no longer require sub create functions like this.
 * @param args
 * @returns
 */
function createPlugin(args) {
    // TODO refactor when there are more required empty fields in plugins
    if (args.type === 'UpdateDelegate') {
        return {
            __kind: args.type,
            fields: [
                args.data || {
                    additionalDelegates: [],
                },
            ],
        };
    }
    return {
        __kind: args.type,
        fields: [args.data || {}],
    };
}
exports.createPlugin = createPlugin;
/**
 * @deprecated Use the new 1.0 sdk instruction helpers like `create` instead of `createV1` which no longer require sub create functions like this.
 * @param args
 * @returns
 */
function pluginAuthorityPair(args) {
    const { type, authority, data } = args;
    return {
        plugin: createPlugin({
            type,
            data,
        }),
        authority: authority ? (0, umi_1.some)(authority) : (0, umi_1.none)(),
    };
}
exports.pluginAuthorityPair = pluginAuthorityPair;
function createPluginV2(args) {
    // TODO refactor when there are more required empty fields in plugins
    const { type } = args;
    if (type === 'UpdateDelegate') {
        return {
            __kind: type,
            fields: [
                args || {
                    additionalDelegates: [],
                },
            ],
        };
    }
    if (type === 'Royalties') {
        return {
            __kind: type,
            fields: [(0, royalties_1.royaltiesToBase)(args)],
        };
    }
    if (type === 'MasterEdition') {
        return {
            __kind: type,
            fields: [(0, masterEdition_1.masterEditionToBase)(args)],
        };
    }
    return {
        __kind: type,
        fields: [args || {}],
    };
}
exports.createPluginV2 = createPluginV2;
/**
 * @deprecated Use the new 1.0 sdk instruction helpers like `create` instead of `createV1` which no longer require sub create functions like this.
 * @param args
 * @returns
 */
function pluginAuthorityPairV2({ type, authority, ...args }) {
    return {
        plugin: createPluginV2({
            type,
            ...args,
        }),
        authority: authority ? (0, umi_1.some)((0, pluginAuthority_1.pluginAuthorityToBase)(authority)) : (0, umi_1.none)(),
    };
}
exports.pluginAuthorityPairV2 = pluginAuthorityPairV2;
function mapPluginFields(fields) {
    return fields.reduce((acc2, field) => ({ ...acc2, ...field }), {});
}
exports.mapPluginFields = mapPluginFields;
function mapPlugin({ plugin: plug, authority, offset, }) {
    const pluginKey = (0, utils_1.toWords)(plug.__kind)
        .toLowerCase()
        .split(' ')
        .reduce((s, c) => s + (c.charAt(0).toUpperCase() + c.slice(1)));
    if (plug.__kind === 'Royalties') {
        return {
            [pluginKey]: {
                authority,
                offset,
                ...(0, royalties_1.royaltiesFromBase)(plug.fields[0]),
            },
        };
    }
    if (plug.__kind === 'MasterEdition') {
        return {
            [pluginKey]: {
                authority,
                offset,
                ...(0, masterEdition_1.masterEditionFromBase)(plug.fields[0]),
            },
        };
    }
    return {
        [pluginKey]: {
            authority,
            offset,
            ...('fields' in plug ? mapPluginFields(plug.fields) : {}),
        },
    };
}
exports.mapPlugin = mapPlugin;
function registryRecordsToPluginsList(registryRecords, accountData) {
    return registryRecords.reduce((acc, record) => {
        const mappedAuthority = (0, pluginAuthority_1.pluginAuthorityFromBase)(record.authority);
        const deserializedPlugin = (0, generated_1.getPluginSerializer)().deserialize(accountData, Number(record.offset))[0];
        acc = {
            ...acc,
            ...mapPlugin({
                plugin: deserializedPlugin,
                authority: mappedAuthority,
                offset: record.offset,
            }),
        };
        return acc;
    }, {});
}
exports.registryRecordsToPluginsList = registryRecordsToPluginsList;
function pluginKeyToPluginType(pluginKey) {
    return (pluginKey.charAt(0).toUpperCase() +
        pluginKey.slice(1));
}
exports.pluginKeyToPluginType = pluginKeyToPluginType;
function parseExternalPluginAdapterData(plugin, record, account) {
    let data;
    if ((0, umi_1.isSome)(record.dataOffset) && (0, umi_1.isSome)(record.dataLen)) {
        const dataSlice = account.slice(Number(record.dataOffset.value), Number(record.dataOffset.value) + Number(record.dataLen.value));
        if (plugin.schema === generated_1.ExternalPluginAdapterSchema.Binary) {
            data = dataSlice;
        }
        else if (plugin.schema === generated_1.ExternalPluginAdapterSchema.Json) {
            // if data is empty, the data slice is uninitialized and should be ignored
            if (dataSlice.length !== 0) {
                try {
                    data = JSON.parse(new TextDecoder().decode(dataSlice));
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    console.warn('Invalid JSON in external plugin data', e.message);
                }
            }
        }
        else if (plugin.schema === generated_1.ExternalPluginAdapterSchema.MsgPack) {
            if (dataSlice.length === 0) {
                data = null;
            }
            else {
                data = (0, msgpack_1.decode)(dataSlice);
            }
        }
        return data;
    }
    throw new Error('Invalid DataStore, missing dataOffset or dataLen');
}
exports.parseExternalPluginAdapterData = parseExternalPluginAdapterData;
//# sourceMappingURL=lib.js.map
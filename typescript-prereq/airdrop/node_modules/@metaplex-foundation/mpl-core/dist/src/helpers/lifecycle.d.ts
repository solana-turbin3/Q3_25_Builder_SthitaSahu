import { Context, PublicKey } from '@metaplex-foundation/umi';
import { AssetV1, CollectionV1 } from '../generated';
export declare enum LifecycleValidationError {
    OracleValidationFailed = "Oracle validation failed.",
    NoAuthority = "No authority to perform this action.",
    AssetFrozen = "Asset is frozen."
}
/**
 * Check if the given authority is eligible to transfer the asset.
 * This does NOT check the asset's royalty rule sets or external plugin adapters. Use `validateTransfer` for more comprehensive checks.
 * @deprecated since v1.0.0. Use `validateTransfer` instead.
 * @param {PublicKey | string} authority Pubkey
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {boolean} True if the pubkey has the authority
 */
export declare function canTransfer(authority: PublicKey | string, asset: AssetV1, collection?: CollectionV1): boolean;
export type ValidateTransferInput = {
    authority: PublicKey | string;
    asset: AssetV1;
    collection?: CollectionV1;
    recipient?: PublicKey;
};
/**
 * Check if the given authority is eligible to transfer the asset and receive an error message if not.
 *
 * @param {Context} context Umi context
 * @param {ValidateTransferInput} inputs Inputs to validate transfer
 * @returns {null | LifecycleValidationError} null if success or error message
 */
export declare function validateTransfer(context: Pick<Context, 'eddsa' | 'rpc'>, { authority, asset, collection, recipient }: ValidateTransferInput): Promise<null | LifecycleValidationError>;
/**
 * Check if the given pubkey is eligible to burn the asset.
 * This does NOT check external plugin adapters, use `validateBurn` for more comprehensive checks.
 * @deprecated since v1.0.0. Use `validateBurn` instead.
 * @param {PublicKey | string} authority Pubkey
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {boolean} True if the pubkey has the authority
 */
export declare function canBurn(authority: PublicKey | string, asset: AssetV1, collection?: CollectionV1): boolean;
export type ValidateBurnInput = {
    authority: PublicKey | string;
    asset: AssetV1;
    collection?: CollectionV1;
};
/**
 * Check if the given authority is eligible to burn the asset and receive an error message if not.
 *
 * @param {Context} context Umi context
 * @param {ValidateBurnInput} inputs Inputs to validate burn
 * @returns {null | LifecycleValidationError} null if success or error message
 */
export declare function validateBurn(context: Pick<Context, 'eddsa' | 'rpc'>, { authority, asset, collection, }: {
    authority: PublicKey | string;
    asset: AssetV1;
    collection?: CollectionV1;
}): Promise<null | LifecycleValidationError>;
/**
 * Check if the given pubkey is eligible to update the asset.
 * This does NOT check external plugin adapters. Use `validateUpdate` for more comprehensive checks.
 * @deprecated since v1.0.0. Use `validateTransfer` instead.
 * @param {PublicKey | string} authority Pubkey
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {boolean} True if the pubkey has the authority
 */
export declare function canUpdate(authority: PublicKey | string, asset: AssetV1, collection?: CollectionV1): boolean;
export type ValidateUpdateInput = {
    authority: PublicKey | string;
    asset: AssetV1;
    collection?: CollectionV1;
};
/**
 * Check if the given authority is eligible to update the asset and receive an error message if not.
 *
 * @param {Context} context Umi context
 * @param {ValidateUpdateInput} inputs Inputs to validate update
 * @returns {null | LifecycleValidationError} null if success or error message
 */
export declare function validateUpdate(context: Pick<Context, 'eddsa' | 'rpc'>, { authority, asset, collection }: ValidateUpdateInput): Promise<null | LifecycleValidationError>;

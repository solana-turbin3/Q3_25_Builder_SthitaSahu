"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAssetOwner = exports.isFrozen = exports.deriveAssetPlugins = exports.deriveExternalPluginAdapters = exports.getExternalPluginAdapterKeyAsString = exports.collectionAddress = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const plugins_1 = require("../plugins");
/**
 * Find the collection address for the given asset if it is part of a collection.
 * @param {AssetV1} asset Asset
 * @returns {PublicKey | undefined} Collection address
 */
function collectionAddress(asset) {
    if (asset.updateAuthority.type === 'Collection') {
        return asset.updateAuthority.address;
    }
    return undefined;
}
exports.collectionAddress = collectionAddress;
const externalPluginAdapterKeys = [
    'oracles',
    'appDatas',
    'lifecycleHooks',
    'dataSections',
    'linkedAppDatas',
];
const getExternalPluginAdapterKeyAsString = (plugin) => {
    switch (plugin.type) {
        case 'Oracle':
            return `${plugin.type}-${plugin.baseAddress}`;
        case 'AppData':
            return `${plugin.type}-${plugin.dataAuthority.type}${plugin.dataAuthority.address ? `-${plugin.dataAuthority.address}` : ''}`;
        case 'LifecycleHook':
            return `${plugin.type}-${plugin.hookedProgram}`;
        case 'LinkedAppData':
            return `${plugin.type}-${plugin.dataAuthority.type}${plugin.dataAuthority.address ? `-${plugin.dataAuthority.address}` : ''}`;
        case 'DataSection':
            return `${plugin.type}-${(0, exports.getExternalPluginAdapterKeyAsString)(plugin.parentKey)}`;
        default:
            throw new Error('Unknown ExternalPluginAdapter type');
    }
};
exports.getExternalPluginAdapterKeyAsString = getExternalPluginAdapterKeyAsString;
const deriveExternalPluginAdapters = (asset, collection) => {
    if (!collection) {
        return asset;
    }
    const externalPluginAdapters = {};
    externalPluginAdapterKeys.forEach((key) => {
        const set = new Set();
        if (asset[key] || collection[key]) {
            externalPluginAdapters[key] = [];
        }
        asset[key]?.forEach((plugin) => {
            set.add((0, exports.getExternalPluginAdapterKeyAsString)(plugin));
            externalPluginAdapters[key]?.push(plugin);
        });
        collection[key]?.forEach((plugin) => {
            if (!set.has((0, exports.getExternalPluginAdapterKeyAsString)(plugin))) {
                externalPluginAdapters[key]?.push(plugin);
            }
        });
    });
    return externalPluginAdapters;
};
exports.deriveExternalPluginAdapters = deriveExternalPluginAdapters;
/**
 * Derive the asset plugins from the asset and collection. Plugins on the asset take precedence over plugins on the collection.
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {AssetV1} Asset with plugins
 */
function deriveAssetPlugins(asset, collection) {
    if (!collection) {
        return asset;
    }
    const externalPluginAdapters = (0, exports.deriveExternalPluginAdapters)(asset, collection);
    // for every data section, find a matching linked plugin and inject the data for convenience
    externalPluginAdapters.dataSections?.forEach((dataSection) => {
        let appData;
        let dataAuth;
        switch (dataSection.parentKey.type) {
            case 'LinkedAppData':
                dataAuth = dataSection.parentKey.dataAuthority;
                appData = externalPluginAdapters.linkedAppDatas?.find((plugin) => (0, plugins_1.comparePluginAuthorities)(dataAuth, plugin.dataAuthority));
                if (appData) {
                    appData.data = dataSection.data;
                }
                break;
            case 'LinkedLifecycleHook':
            default:
                throw new Error('LinkedLifecycleHook currently unsupported');
        }
    });
    const { numMinted, currentSize, masterEdition, ...colRest } = collection; // remove collection only fields
    return {
        ...colRest,
        ...asset,
        ...externalPluginAdapters,
    };
}
exports.deriveAssetPlugins = deriveAssetPlugins;
/**
 * Check if the asset is frozen.
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {boolean} True if the asset is frozen
 */
function isFrozen(asset, collection) {
    const dAsset = deriveAssetPlugins(asset, collection);
    return (dAsset.freezeDelegate?.frozen ||
        dAsset.permanentFreezeDelegate?.frozen ||
        false);
}
exports.isFrozen = isFrozen;
/**
 * Check if the given pubkey is the owner of the asset.
 * @param {string | PublicKey} pubkey Pubkey
 * @param {AssetV1} asset Asset
 * @returns {boolean} True if the pubkey is the owner
 */
function isAssetOwner(pubkey, asset) {
    const key = (0, umi_1.publicKey)(pubkey);
    return key === asset.owner;
}
exports.isAssetOwner = isAssetOwner;
//# sourceMappingURL=state.js.map
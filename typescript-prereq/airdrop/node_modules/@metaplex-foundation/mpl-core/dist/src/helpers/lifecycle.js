"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateUpdate = exports.canUpdate = exports.validateBurn = exports.canBurn = exports.validateTransfer = exports.canTransfer = exports.LifecycleValidationError = void 0;
const generated_1 = require("../generated");
const state_1 = require("./state");
const plugin_1 = require("./plugin");
const authority_1 = require("./authority");
const plugins_1 = require("../plugins");
var LifecycleValidationError;
(function (LifecycleValidationError) {
    LifecycleValidationError["OracleValidationFailed"] = "Oracle validation failed.";
    LifecycleValidationError["NoAuthority"] = "No authority to perform this action.";
    LifecycleValidationError["AssetFrozen"] = "Asset is frozen.";
})(LifecycleValidationError = exports.LifecycleValidationError || (exports.LifecycleValidationError = {}));
/**
 * Check if the given authority is eligible to transfer the asset.
 * This does NOT check the asset's royalty rule sets or external plugin adapters. Use `validateTransfer` for more comprehensive checks.
 * @deprecated since v1.0.0. Use `validateTransfer` instead.
 * @param {PublicKey | string} authority Pubkey
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {boolean} True if the pubkey has the authority
 */
function canTransfer(authority, asset, collection) {
    const dAsset = (0, state_1.deriveAssetPlugins)(asset, collection);
    // Permanent plugins have force approve powers
    const permaTransferDelegate = (0, plugin_1.checkPluginAuthorities)({
        authority,
        pluginTypes: [generated_1.PluginType.PermanentTransferDelegate],
        asset: dAsset,
        collection,
    });
    if (permaTransferDelegate.some((d) => d)) {
        return true;
    }
    if ((0, state_1.isFrozen)(asset, collection)) {
        return false;
    }
    if (dAsset.owner === authority) {
        return true;
    }
    const transferDelegates = (0, plugin_1.checkPluginAuthorities)({
        authority,
        pluginTypes: [generated_1.PluginType.TransferDelegate],
        asset: dAsset,
        collection,
    });
    return transferDelegates.some((d) => d);
}
exports.canTransfer = canTransfer;
/**
 * Check if the given authority is eligible to transfer the asset and receive an error message if not.
 *
 * @param {Context} context Umi context
 * @param {ValidateTransferInput} inputs Inputs to validate transfer
 * @returns {null | LifecycleValidationError} null if success or error message
 */
async function validateTransfer(context, { authority, asset, collection, recipient }) {
    const dAsset = (0, state_1.deriveAssetPlugins)(asset, collection);
    // Permanent plugins have force approve powers
    const permaTransferDelegate = (0, plugin_1.checkPluginAuthorities)({
        authority,
        pluginTypes: [generated_1.PluginType.PermanentTransferDelegate],
        asset: dAsset,
        collection,
    });
    if (permaTransferDelegate.some((d) => d)) {
        return null;
    }
    if ((0, state_1.isFrozen)(asset, collection)) {
        return LifecycleValidationError.AssetFrozen;
    }
    if (dAsset.oracles?.length) {
        const eligibleOracles = dAsset.oracles
            .filter((o) => o.lifecycleChecks?.transfer?.includes(plugins_1.CheckResult.CAN_REJECT))
            .filter((o) => {
            // there's no PDA to derive, we can check the oracle account
            if (!o.baseAddressConfig) {
                return true;
            }
            // If there's a recipient in the inputs, we can try to check the oracle account
            if (recipient) {
                return true;
            }
            if (!(0, plugins_1.getExtraAccountRequiredInputs)(o.baseAddressConfig).includes('recipient')) {
                return true;
            }
            // we skip the check if there's a recipient required but no recipient provided
            // this is due how UIs generally show the availability of the transfer button before requiring the recipient address
            return false;
        });
        if (eligibleOracles.length) {
            const accountsWithOffset = eligibleOracles.map((o) => {
                const account = (0, plugins_1.findOracleAccount)(context, o, {
                    asset: asset.publicKey,
                    collection: collection?.publicKey,
                    owner: asset.owner,
                    recipient,
                });
                return {
                    pubkey: account,
                    offset: o.resultsOffset,
                };
            });
            const oracleValidations = (await context.rpc.getAccounts(accountsWithOffset.map((a) => a.pubkey))).map((a, index) => {
                if (a.exists) {
                    return (0, plugins_1.deserializeOracleValidation)(a.data, accountsWithOffset[index].offset);
                }
                return null;
            });
            const oraclePass = oracleValidations.every((v) => {
                if (v?.__kind === 'Uninitialized') {
                    return false;
                }
                return v?.transfer === generated_1.ExternalValidationResult.Pass;
            });
            if (!oraclePass) {
                return LifecycleValidationError.OracleValidationFailed;
            }
        }
    }
    if (dAsset.owner === authority) {
        return null;
    }
    const transferDelegates = (0, plugin_1.checkPluginAuthorities)({
        authority,
        pluginTypes: [generated_1.PluginType.TransferDelegate],
        asset: dAsset,
        collection,
    });
    if (transferDelegates.some((d) => d)) {
        return null;
    }
    return LifecycleValidationError.NoAuthority;
}
exports.validateTransfer = validateTransfer;
/**
 * Check if the given pubkey is eligible to burn the asset.
 * This does NOT check external plugin adapters, use `validateBurn` for more comprehensive checks.
 * @deprecated since v1.0.0. Use `validateBurn` instead.
 * @param {PublicKey | string} authority Pubkey
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {boolean} True if the pubkey has the authority
 */
function canBurn(authority, asset, collection) {
    const dAsset = (0, state_1.deriveAssetPlugins)(asset, collection);
    const permaBurnDelegate = (0, plugin_1.checkPluginAuthorities)({
        authority,
        pluginTypes: [generated_1.PluginType.PermanentBurnDelegate],
        asset: dAsset,
        collection,
    });
    if (permaBurnDelegate.some((d) => d)) {
        return true;
    }
    if ((0, state_1.isFrozen)(asset, collection)) {
        return false;
    }
    if (dAsset.owner === authority) {
        return true;
    }
    const burnDelegates = (0, plugin_1.checkPluginAuthorities)({
        authority,
        pluginTypes: [generated_1.PluginType.BurnDelegate],
        asset,
        collection,
    });
    return burnDelegates.some((d) => d);
}
exports.canBurn = canBurn;
/**
 * Check if the given authority is eligible to burn the asset and receive an error message if not.
 *
 * @param {Context} context Umi context
 * @param {ValidateBurnInput} inputs Inputs to validate burn
 * @returns {null | LifecycleValidationError} null if success or error message
 */
async function validateBurn(context, { authority, asset, collection, }) {
    const dAsset = (0, state_1.deriveAssetPlugins)(asset, collection);
    const permaBurnDelegate = (0, plugin_1.checkPluginAuthorities)({
        authority,
        pluginTypes: [generated_1.PluginType.PermanentBurnDelegate],
        asset: dAsset,
        collection,
    });
    if (permaBurnDelegate.some((d) => d)) {
        return null;
    }
    if ((0, state_1.isFrozen)(asset, collection)) {
        return LifecycleValidationError.AssetFrozen;
    }
    if (dAsset.oracles?.length) {
        const eligibleOracles = dAsset.oracles.filter((o) => o.lifecycleChecks?.burn?.includes(plugins_1.CheckResult.CAN_REJECT));
        if (eligibleOracles.length) {
            const accountsWithOffset = eligibleOracles.map((o) => {
                const account = (0, plugins_1.findOracleAccount)(context, o, {
                    asset: asset.publicKey,
                    collection: collection?.publicKey,
                    owner: asset.owner,
                });
                return {
                    pubkey: account,
                    offset: o.resultsOffset,
                };
            });
            const oracleValidations = (await context.rpc.getAccounts(accountsWithOffset.map((a) => a.pubkey))).map((a, index) => {
                if (a.exists) {
                    return (0, plugins_1.deserializeOracleValidation)(a.data, accountsWithOffset[index].offset);
                }
                return null;
            });
            const oraclePass = oracleValidations.every((v) => {
                if (v?.__kind === 'Uninitialized') {
                    return false;
                }
                return v?.burn === generated_1.ExternalValidationResult.Pass;
            });
            if (!oraclePass) {
                return LifecycleValidationError.OracleValidationFailed;
            }
        }
    }
    if (dAsset.owner === authority) {
        return null;
    }
    const burnDelegates = (0, plugin_1.checkPluginAuthorities)({
        authority,
        pluginTypes: [generated_1.PluginType.BurnDelegate],
        asset,
        collection,
    });
    if (burnDelegates.some((d) => d)) {
        return null;
    }
    return LifecycleValidationError.NoAuthority;
}
exports.validateBurn = validateBurn;
/**
 * Check if the given pubkey is eligible to update the asset.
 * This does NOT check external plugin adapters. Use `validateUpdate` for more comprehensive checks.
 * @deprecated since v1.0.0. Use `validateTransfer` instead.
 * @param {PublicKey | string} authority Pubkey
 * @param {AssetV1} asset Asset
 * @param {CollectionV1 | undefined} collection Collection
 * @returns {boolean} True if the pubkey has the authority
 */
function canUpdate(authority, asset, collection) {
    return (0, authority_1.hasAssetUpdateAuthority)(authority, asset, collection);
}
exports.canUpdate = canUpdate;
/**
 * Check if the given authority is eligible to update the asset and receive an error message if not.
 *
 * @param {Context} context Umi context
 * @param {ValidateUpdateInput} inputs Inputs to validate update
 * @returns {null | LifecycleValidationError} null if success or error message
 */
async function validateUpdate(context, { authority, asset, collection }) {
    if (asset.oracles?.length) {
        const eligibleOracles = asset.oracles.filter((o) => o.lifecycleChecks?.update?.includes(plugins_1.CheckResult.CAN_REJECT));
        if (eligibleOracles.length) {
            const accountsWithOffset = eligibleOracles.map((o) => {
                const account = (0, plugins_1.findOracleAccount)(context, o, {
                    asset: asset.publicKey,
                    collection: collection?.publicKey,
                    owner: asset.owner,
                });
                return {
                    pubkey: account,
                    offset: o.resultsOffset,
                };
            });
            const oracleValidations = (await context.rpc.getAccounts(accountsWithOffset.map((a) => a.pubkey))).map((a, index) => {
                if (a.exists) {
                    return (0, plugins_1.deserializeOracleValidation)(a.data, accountsWithOffset[index].offset);
                }
                return null;
            });
            const oraclePass = oracleValidations.every((v) => {
                if (v?.__kind === 'Uninitialized') {
                    return false;
                }
                return v?.update === generated_1.ExternalValidationResult.Pass;
            });
            if (!oraclePass) {
                return LifecycleValidationError.OracleValidationFailed;
            }
        }
    }
    if (!(0, authority_1.hasAssetUpdateAuthority)(authority, asset, collection)) {
        return LifecycleValidationError.NoAuthority;
    }
    return null;
}
exports.validateUpdate = validateUpdate;
//# sourceMappingURL=lifecycle.js.map
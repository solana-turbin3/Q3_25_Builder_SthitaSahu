"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCollection = exports.fetchAllAssets = exports.fetchAsset = exports.fetchCollectionsByUpdateAuthority = exports.fetchAssetsByCollection = exports.fetchAssetsByOwner = exports.deriveAssetPluginsWithFetch = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const generated_1 = require("../generated");
const plugins_1 = require("../plugins");
const state_1 = require("./state");
/**
 * Helper function to derive plugins for a list of assets while fetching relevant collections.
 *
 * @param umi Context
 * @param assets Assets to derive plugins for
 * @returns Promise of a list of `AssetV1`
 */
const deriveAssetPluginsWithFetch = async (umi, assets) => {
    const collectionKeys = Array.from(new Set(assets.map((asset) => (0, state_1.collectionAddress)(asset)))).filter((collection) => !!collection);
    const collections = await (0, generated_1.fetchAllCollectionV1)(umi, collectionKeys);
    const collectionMap = collections.reduce((map, collection) => {
        map[collection.publicKey] = collection;
        return map;
    }, {});
    return assets.map((asset) => {
        const collection = (0, state_1.collectionAddress)(asset);
        if (!collection) {
            return asset;
        }
        return (0, state_1.deriveAssetPlugins)(asset, collectionMap[collection]);
    });
};
exports.deriveAssetPluginsWithFetch = deriveAssetPluginsWithFetch;
/**
 * Helper function to fetch assets by owner using GPA. For more filters, use the `getAssetV1GpaBuilder` directly.
 * For faster performance or more flexible queries, use DAS with `mpl-core-das` package.
 *
 * @param umi Context
 * @param owner Owner of the assets
 * @param options Options, `skipDerivePlugins` plugins from collection is false by default
 * @returns Promise of a list of `AssetV1`
 */
const fetchAssetsByOwner = async (umi, owner, options = {}) => {
    const assets = await (0, generated_1.getAssetV1GpaBuilder)(umi)
        .whereField('key', generated_1.Key.AssetV1)
        .whereField('owner', (0, umi_1.publicKey)(owner))
        .getDeserialized();
    if (options.skipDerivePlugins) {
        return assets;
    }
    return (0, exports.deriveAssetPluginsWithFetch)(umi, assets);
};
exports.fetchAssetsByOwner = fetchAssetsByOwner;
/**
 * Helper function to fetch assets by collection using GPA. For more filters, use the `getAssetV1GpaBuilder` directly.
 * For faster performance or more flexible queries, use DAS with `mpl-core-das` package.
 *
 * @param umi Context
 * @param collection Assets that belong to this collection
 * @param options Options, `skipDerivePlugins` plugins from collection is false by default
 * @returns Promise of a list of `AssetV1`
 */
const fetchAssetsByCollection = async (umi, collection, options = {}) => {
    const assets = await (0, generated_1.getAssetV1GpaBuilder)(umi)
        .whereField('key', generated_1.Key.AssetV1)
        .whereField('updateAuthority', (0, plugins_1.updateAuthority)('Collection', [(0, umi_1.publicKey)(collection)]))
        .getDeserialized();
    if (options.skipDerivePlugins) {
        return assets;
    }
    return (0, exports.deriveAssetPluginsWithFetch)(umi, assets);
};
exports.fetchAssetsByCollection = fetchAssetsByCollection;
/**
 * Helper function to fetch collections by update authority using GPA. For more filters, use the `getCollectionV1GpaBuilder` directly.
 * For faster performance or more flexible queries, use DAS with `mpl-core-das` package.
 *
 * @param umi Context
 * @param authority Update authority of the collections
 * @returns
 */
const fetchCollectionsByUpdateAuthority = async (umi, authority) => (0, generated_1.getCollectionV1GpaBuilder)(umi)
    .whereField('key', generated_1.Key.CollectionV1)
    .whereField('updateAuthority', (0, umi_1.publicKey)(authority))
    .getDeserialized();
exports.fetchCollectionsByUpdateAuthority = fetchCollectionsByUpdateAuthority;
/**
 * Helper function to fetch an asset and derive plugins from the collection if applicable.
 *
 * @param umi
 * @param asset
 * @param options
 */
const fetchAsset = async (umi, asset, options = {}) => {
    const assetV1 = await (0, generated_1.fetchAssetV1)(umi, (0, umi_1.publicKey)(asset));
    if (options.skipDerivePlugins) {
        return assetV1;
    }
    const collection = (0, state_1.collectionAddress)(assetV1);
    if (!collection) {
        return assetV1;
    }
    return (0, state_1.deriveAssetPlugins)(assetV1, await (0, generated_1.fetchCollectionV1)(umi, collection));
};
exports.fetchAsset = fetchAsset;
/**
 * Helper function to fetch multiple assets and derive plugins from their collections if applicable.
 *
 * @param umi Context
 * @param assets Array of asset addresses to fetch
 * @param options Options, `skipDerivePlugins` plugins from collection is false by default; `chunksize` how many assets to fetch in a single rpc call.
 * @returns Promise of a list of `AssetV1`
 */
const fetchAllAssets = async (umi, assets, options = {}) => {
    const chunkSize = options.chunkSize ?? 1000;
    const assetChunks = [];
    for (let i = 0; i < assets.length; i += chunkSize) {
        assetChunks.push(assets.slice(i, i + chunkSize));
    }
    const assetV1s = (await Promise.all(assetChunks.map((chunk) => (0, generated_1.fetchAllAssetV1)(umi, chunk.map((asset) => (0, umi_1.publicKey)(asset)))))).flat();
    if (options.skipDerivePlugins) {
        return assetV1s;
    }
    const collectionKeys = Array.from(new Set(assetV1s.map((asset) => (0, state_1.collectionAddress)(asset)))).filter((collection) => !!collection);
    const collections = await (0, generated_1.fetchAllCollectionV1)(umi, collectionKeys);
    const collectionMap = collections.reduce((map, collection) => {
        map[collection.publicKey] = collection;
        return map;
    }, {});
    return assetV1s.map((assetV1) => {
        const collection = (0, state_1.collectionAddress)(assetV1);
        if (!collection) {
            return assetV1;
        }
        return (0, state_1.deriveAssetPlugins)(assetV1, collectionMap[collection]);
    });
};
exports.fetchAllAssets = fetchAllAssets;
/**
 * Helper function to fetch a collection.
 *
 * @param umi
 * @param collection
 */
const fetchCollection = async (umi, collection, options) => (0, generated_1.fetchCollectionV1)(umi, (0, umi_1.publicKey)(collection), options);
exports.fetchCollection = fetchCollection;
//# sourceMappingURL=fetch.js.map
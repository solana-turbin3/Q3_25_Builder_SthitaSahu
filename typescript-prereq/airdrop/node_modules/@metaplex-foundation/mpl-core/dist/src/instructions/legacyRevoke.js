"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.legacyRevoke = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const generated_1 = require("../generated");
const errors_1 = require("./errors");
const plugins_1 = require("../plugins");
function legacyRevoke(context, asset) {
    const definedPlugins = (({ freezeDelegate, transferDelegate, burnDelegate, }) => ({
        ...(freezeDelegate ? { freezeDelegate } : {}),
        ...(transferDelegate ? { transferDelegate } : {}),
        ...(burnDelegate ? { burnDelegate } : {}),
    }))(asset);
    const definedPluginsValues = Object.values(definedPlugins);
    const canRevoke = definedPluginsValues.length > 0 &&
        definedPluginsValues.every((pluginValue) => {
            const assetOwner = asset.owner;
            const pluginAuthority = pluginValue.authority;
            return (pluginAuthority.type !== 'Owner' &&
                pluginAuthority.address !== assetOwner);
        });
    if (!canRevoke) {
        throw new Error(errors_1.ERR_CANNOT_REVOKE);
    }
    let txBuilder = (0, umi_1.transactionBuilder)();
    // Change the plugin authority of the defined plugins.
    Object.keys(definedPlugins).forEach((pluginKey) => {
        const plugType = (0, plugins_1.pluginKeyToPluginType)(pluginKey);
        txBuilder = txBuilder.add((0, generated_1.revokePluginAuthorityV1)(context, {
            asset: asset.publicKey,
            pluginType: generated_1.PluginType[plugType],
        }));
    });
    return txBuilder;
}
exports.legacyRevoke = legacyRevoke;
//# sourceMappingURL=legacyRevoke.js.map
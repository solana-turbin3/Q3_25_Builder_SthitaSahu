"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// @ts-nocheck
const umi_1 = require("@metaplex-foundation/umi");
const index_1 = require("./index");
const example = async () => {
    const umi = await (0, umi_1.createUmi)();
    // Create an asset
    const assetAddress = (0, umi_1.generateSigner)(umi);
    const owner = (0, umi_1.generateSigner)(umi);
    await (0, index_1.create)(umi, {
        name: 'Test Asset',
        uri: 'https://example.com/asset.json',
        asset: assetAddress,
        owner: owner.publicKey, // optional, will default to payer
    }).sendAndConfirm(umi);
    // Fetch an asset
    const asset = await (0, index_1.fetchAssetV1)(umi, assetAddress.publicKey);
    // Create a collection
    const collectionUpdateAuthority = (0, umi_1.generateSigner)(umi);
    const collectionAddress = (0, umi_1.generateSigner)(umi);
    await (0, index_1.createCollection)(umi, {
        name: 'Test Collection',
        uri: 'https://example.com/collection.json',
        collection: collectionAddress,
        updateAuthority: collectionUpdateAuthority.publicKey, // optional, defaults to payer
    }).sendAndConfirm(umi);
    // Fetch a collection
    const collection = await (0, index_1.fetchCollectionV1)(umi, collectionAddress.publicKey);
    // Create an asset in a collection, the authority must be the updateAuthority of the collection
    await (0, index_1.create)(umi, {
        name: 'Test Asset',
        uri: 'https://example.com/asset.json',
        asset: assetAddress,
        collection,
        authority: collectionUpdateAuthority, // optional, defaults to payer
    }).sendAndConfirm(umi);
    // Transfer an asset
    const recipient = (0, umi_1.generateSigner)(umi);
    await (0, index_1.transfer)(umi, {
        asset,
        newOwner: recipient.publicKey,
    }).sendAndConfirm(umi);
    // Transfer an asset in a collection
    await (0, index_1.transfer)(umi, {
        asset,
        newOwner: recipient.publicKey,
        collection,
    }).sendAndConfirm(umi);
    // GPA fetch assets by owner
    const assetsByOwner = await (0, index_1.getAssetV1GpaBuilder)(umi)
        .whereField('key', index_1.Key.AssetV1)
        .whereField('owner', owner.publicKey)
        .getDeserialized();
    // GPA fetch assets by collection
    const assetsByCollection = await (0, index_1.getAssetV1GpaBuilder)(umi)
        .whereField('key', index_1.Key.AssetV1)
        .whereField('updateAuthority', (0, index_1.updateAuthority)('Collection', [collectionAddress.publicKey]))
        .getDeserialized();
    // DAS API (RPC based indexing) fetch assets by owner/collection
    // Coming soon
};
const advancedExamples = async () => {
    const umi = await (0, umi_1.createUmi)();
    // Freezing an asset
    const assetAddress = (0, umi_1.generateSigner)(umi);
    const freezeDelegate = (0, umi_1.generateSigner)(umi);
    await (0, index_1.addPlugin)(umi, {
        asset: assetAddress.publicKey,
        // adds the owner-managed freeze plugin to the asset
        plugin: {
            type: 'FreezeDelegate',
            frozen: true,
            // Optionally set the authority to a delegate who can unfreeze. If unset, this will be the Owner
            // This is functionally the same as calling addPlugin and approvePluginAuthority separately.
            // Freezing with a delegate is commonly used for escrowless staking programs.
            authority: {
                type: 'Address',
                address: freezeDelegate.publicKey,
            },
        },
    }).sendAndConfirm(umi);
    // Unfreezing an asset with a delegate
    // Revoking an authority will revert the authority back to the owner for owner-managed plugins
    await (0, index_1.revokePluginAuthority)(umi, {
        asset: assetAddress.publicKey,
        plugin: {
            type: 'FreezeDelegate',
        },
        authority: freezeDelegate,
    }).sendAndConfirm(umi);
    // Create a collection with royalties
    const collectionAddress = (0, umi_1.generateSigner)(umi);
    const creator1 = (0, umi_1.generateSigner)(umi);
    const creator2 = (0, umi_1.generateSigner)(umi);
    await (0, index_1.createCollection)(umi, {
        name: 'Test Collection',
        uri: 'https://example.com/collection.json',
        collection: collectionAddress,
        plugins: [
            {
                type: 'Royalties',
                basisPoints: 500,
                creators: [
                    {
                        address: creator1.publicKey,
                        percentage: 20,
                    },
                    {
                        address: creator2.publicKey,
                        percentage: 80,
                    },
                ],
                ruleSet: (0, index_1.ruleSet)('None'), // Compatibility rule set
            },
        ],
    }).sendAndConfirm(umi);
    // Create an asset in a collection.
    // Assets in a collection will inherit the collection's authority-managed plugins, in this case the royalties plugin
    await (0, index_1.create)(umi, {
        name: 'Test Asset',
        uri: 'https://example.com/asset.json',
        asset: assetAddress,
        collection: await (0, index_1.fetchCollectionV1)(umi, collectionAddress.publicKey),
    }).sendAndConfirm(umi);
};
//# sourceMappingURL=demo.js.map